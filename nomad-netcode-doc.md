# Nomad - Netcode Implementation
This document specifies the basic operation of the net code module for Nomad.

----
## Contents
- Overview
- Protocol
- Event Packets
- Anti Cheat
- Offline Play

----
## Overview

Nomad can be broken down into three core modules:
- User Interface
- Netcode
- Game Simulation

The user interface layer polls all input from the user and together with the
current state of the world generates events that inform the game state of the
users requested actions.

These events are not directly send to the game simulation, instead then are sent
via the netcode to an event relay.

At the same time the game simulation polls the netcode for all events that have
been received from the relay server.  These events are then put into action by
the game simulation module.

So in this setup the netcode and the relay server sit in between the events that
are generated by the user interface and consumes by the game simulation.  The
user interface must never directly send messages to the game simulation and
bypass the event relay.

The game simulation module of Nomad must be carefully crafted to it is entirely
deterministic and only changed states based on the events that it receives from
the relay server.  If the game simulation operates in this manner, two game
simulation modules with the same initial state will model exactly the exact same
state given that they receive the exact same stream of events.

Many clients can be connected to the relay server and send it events in any
order they wish.  The relay server will poll all connected clients for events,
connected them all into a single linear stream of events and transmit exactly
that same stream back to all clients in parallel.

This ensures that all clients receive the sum total of all events and they share
the same sequence of reception.  Thus every connected client shares the same
collective simulation.  Another important benefit is that events are generated
at a consistent low rate, implying a consistent and low bandwidth requirement.


----
## Protocol

##### Event header
As the game is constructed it is not feasible to predict all possible event
packets that will be required.  To this end, Nomad uses a generic event format
that allows for any number of different events to be sent and received. All
events share the following header:

```
struct event_header_t {
  uint16_t size_;
  uint16_t type_;
  uint16_t checksum_;
  uint16_t sender_;
};
```

The 'size_' field records the total length in bytes of the body that follows the
event header.  The 'type_' field is an enum that specifies the type of event
this is, and so how the body should be interpreted.  'checksum_' is a 16bit
addler checksum of the event body, providing a limited validation of the event
stream.  The sender field is the uuid of the client that sent this packet.

##### Event body
Immediately following the header is the body of the event.  Bodies are specific
to the event being sent and may range from zero to 64kb in size.  The body has
no restriction placed on their layout or contents.  An event packet reader
should consult the 'type_' field to discover the format and layout of the event
body.


----
## Event Packets

##### e_event_set_uuid
```
struct e_event_set_uuid_t {
  uint32_t uuid_;
};
```
The event relay server sends each new client a e_event_set_uuid packet that
contains a UUID unique to this client only.


##### e_client_info
```
struct e_client_info_t {
  uint32_t count_;
  uint32_t uuid_[count_]
};
```
The event relay server sends all connected clients an e_client_info packet when
there is any change in the number of connected clients.


##### e_event_frame
```
struct e_event_frame_t {
  uint32_t frame_number_;
};
```
During game play the e_event_frame packet will be send out at a rate of ~10hz.
On receipt of this packet, the game simulation module should perform exactly one
simulation step.


##### e_event_set_var
```
struct e_event_set_var_t {
  uint32_t var_type_;
  uint32_t name_len_;
  char name[name_len_];
  uint32_t var_len_;
  uint32_t var_type_;
  union {
    int var_int_;
    int var_float_;
  } u_;
};
```
The game has several named variables that control specific aspects of the
simulation.  These variables may be adjusted during the course of the game as
players see fit.  This packet allows variable changes to be kept in sync between
all connected peers.

Examples of named variables may be:
- Game speed
- Difficulty
- Time limit


##### e_event_chat
```
struct e_event_chat_t {
  uint32_t size_;
  char message_[size_];
};
```
During a game players may wish to send each other short text messages.  The
e_event_chat packet allows these messages to be broadcast from one player to all
connected peers.


----
## Anti Cheat
The plan for the initial release is to support single player, and multiplayer
running over a Local Area Network.  Players could use a VPN solution to allow
them to play over the WAN.  An option for extension would be to support native
WAN play, so it will be briefly analysed here.

LAN play has a measure of implied trust because it is fairly clear to you who
you are playing against.  WAN play on the other hand has zero implied trust as
each player can be completely anonymous, opening the possibilities for cheating.
When supporting WAN play, measures should be taken to disencourage cheating.

Cheating could occur in the following ways:

##### Event spoofing
One player sends events to the relay, marked as originating from a different
player.

This can be mitigated by having the relay server only accept packets from a
client when the UUID is correct.  Combined with this, each client can check
that the UUID is performing a action valid for it.

##### Game state inspection
Since each peer simulates a complete version of the game, it would be possible
for one player to access data about their opponents that should remain hidden
from them.


----
## Offline Play
Local offline play still uses the netcode module, the different being that a
players computer hosts the relay server on the local loopback device 127.0.0.1.
The client and all AI players then connect to the local loopback
relay server, instead of a remote relay server.  This has the advantage that
local and multiplayer games use the same code path giving better coverage.
